# Импортируем библиотеки
# numpy — библиотека для работы с числами, векторами и матрицами
# matplotlib — библиотека для построения графиков
import numpy as np
import matplotlib.pyplot as plt


# Задаём два вектора в двумерном пространстве
# v1 = (2, 3), v2 = (1, -1)
# Векторы — это "стрелки" в пространстве, задающие направление и длину
v1 = np.array([2, 3])
v2 = np.array([1, -1])

# Находим длину (норму) каждого вектора.
# Формула: ||v|| = sqrt(x^2 + y^2)
# Это обычная длина стрелки (по теореме Пифагора).
norm_v1 = np.linalg.norm(v1)
norm_v2 = np.linalg.norm(v2)

# Находим скалярное произведение двух векторов.
# Формула: v1 · v2 = |v1| * |v2| * cos(θ)
# Оно показывает "насколько два вектора смотрят в одном направлении".
dot = np.dot(v1, v2)

# Теперь найдём угол между векторами.
# cos(θ) = (v1 · v2) / (||v1|| * ||v2||)
cos_theta = dot / (norm_v1 * norm_v2)
theta = np.arccos(cos_theta)  # в радианах

print("||v1|| =", norm_v1)
print("||v2|| =", norm_v2)
print("dot(v1, v2) =", dot)
print("theta (в градусах) =", np.degrees(theta))


# Задаём матрицу вращения на угол 90 градусов против часовой стрелки.
# Она выглядит так:
# R = [[0, -1],
#      [1,  0]]
# Эта матрица при умножении "поворачивает" векторы в 2D-плоскости.
R = np.array([[0, -1],
              [1,  0]])

# Умножаем матрицу на вектор v1.
# Это делается с помощью оператора @ (или np.dot).
# Новый вектор — это v1, повернутый на 90 градусов.
v1_rotated = R @ v1

# Визуализируем исходный и повернутый векторы.
plt.figure()

# Рисуем исходный вектор v1 (синий)
plt.quiver(0, 0, v1[0], v1[1], angles='xy', scale_units='xy', scale=1, color='blue', label='v1')
# Рисуем повернутый вектор (красный)
plt.quiver(0, 0, v1_rotated[0], v1_rotated[1], angles='xy', scale_units='xy', scale=1, color='red', label='R*v1')
# Ограничим область отображения
plt.xlim(-4, 4)
plt.ylim(-4, 4)
# Делаем шкалу равной (чтобы не искажать угол)
plt.gca().set_aspect('equal', adjustable='box')
plt.legend()
plt.show()

# Вычисляем собственные значения (eigenvalues) и собственные векторы (eigenvectors).
# Собственный вектор — это такой вектор, который после применения матрицы
# НЕ меняет направления, а только растягивается/сжимается.
# Собственное значение показывает во сколько раз вектор растянулся/сжался.)
eigvals, eigvecs = np.linalg.eig(R)

print("Eigenvalues:", eigvals)
print("Eigenvectors:\n", eigvecs)