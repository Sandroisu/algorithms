import numpy as np
import matplotlib.pyplot as plt

# -----------------------------
# 1. Исходный вектор
# -----------------------------
v = np.array([2, 1])
print("Исходный вектор:", v)

# -----------------------------
# 2. Матрица поворота (45°)
# -----------------------------
theta = np.pi / 4  # угол в радианах
R = np.array([[np.cos(theta), -np.sin(theta)],
              [np.sin(theta),  np.cos(theta)]])

# -----------------------------
# 3. Матрица масштабирования
# -----------------------------
S = np.array([[1.5, 0],
              [0, 0.7]])

# -----------------------------
# 4. Матрица отражения относительно оси X
# -----------------------------
Rx = np.array([[1, 0],
               [0, -1]])

# -----------------------------
# 5. Итоговое преобразование
# -----------------------------
# Если мы применяем операции последовательно:
# v' = Rx * S * R * v
# то общая матрица = Rx @ S @ R
T = Rx @ S @ R

print("Итоговая матрица преобразования T:\n", T)

# -----------------------------
# 6. Проверим: два способа дают один результат
# -----------------------------

# a) Последовательно
v_stepwise = Rx @ (S @ (R @ v))

# b) Одним шагом через итоговую матрицу
v_combined = T @ v

print("Результат по шагам:", v_stepwise)
print("Результат одной матрицей:", v_combined)

# -----------------------------
# 7. Визуализация
# -----------------------------
plt.figure(figsize=(6, 6))

# Исходный вектор (синий)
plt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1,
           color='blue', label='Исходный')

# После комбинированного преобразования (пурпурный)
plt.quiver(0, 0, v_combined[0], v_combined[1], angles='xy', scale_units='xy', scale=1,
           color='purple', label='После T')

plt.xlim(-5, 5)
plt.ylim(-5, 5)
plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.gca().set_aspect('equal', adjustable='box')
plt.legend()
plt.title("Итоговая матрица как композиция поворота, масштабирования и отражения")
plt.show()
